module.exports="precision highp float;\nfloat mirrored(float v) {\n float m = mod(v, 2.0);\n return mix(m, 2.0 - m, step(1.0, m));\n}\nvec2 mirrored(vec2 v) {\n vec2 m = mod(v, 2.0);\n return mix(m, 2.0 - m, step(1.0, m));\n}\nvec3 mirrored(vec3 v) {\n vec3 m = mod(v, 2.0);\n return mix(m, 2.0 - m, step(1.0, m));\n}\nvec4 mirrored(vec4 v) {\n vec4 m = mod(v, 2.0);\n return mix(m, 2.0 - m, step(1.0, m));\n}\nfloat linear(float t) {\n return t;\n}\nfloat tri(float v) {\n return mix(v, 1.0 - v, step(0.5, v)) * 2.0;\n}\nvec2 tri(vec2 v) {\n return mix(v, 1.0 - v, step(0.5, v)) * 2.0;\n}\nvec3 tri(vec3 v) {\n return mix(v, 1.0 - v, step(0.5, v)) * 2.0;\n}\nvec4 tri(vec4 v) {\n return mix(v, 1.0 - v, step(0.5, v)) * 2.0;\n}\nvarying vec2 vUv;\nvarying float vDark;\nuniform vec4 time;\nuniform float progress;\nuniform vec2 translate;\nuniform vec2 delay;\nuniform vec2 accel;\nuniform float edge;\nuniform vec4 waveAmpFreq;\nuniform vec4 waveSpeedPhase;\nuniform vec2 waveBlend;\nuniform float opacity;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nvoid main(void) {\n vec2 uv = vUv;\n \n float delayValue = progress * (1.0 + delay.x + delay.y) - uv.y * delay.y - (1.0 - uv.x) * delay.x;\n delayValue = linear(clamp(delayValue, 0.0, 1.0));\n \n float progressValue = linear(progress);\n vec2 translateValue = progressValue + delayValue * accel.xy;\n vec2 translateValue1 = translate * translateValue;\n vec2 translateValue2 = translate * (translateValue - 1.0 - accel.xy);\n vec2 w = sin(time.y * waveSpeedPhase.xy + uv.yx * waveAmpFreq.zw + waveSpeedPhase.zw) * waveAmpFreq.xy;\n vec2 xy = (tri(progress) * waveBlend.x + tri(delayValue) * waveBlend.y) * w;\n vec2 uv1 = vUv + translateValue1 + xy;\n vec2 uv2 = vUv + translateValue2 + xy;\n vec4 rgba1 = texture2D(texture1, mirrored(uv1));\n vec4 rgba2 = texture2D(texture2, mirrored(uv2));\n float threshold = step(1.0 - uv.x, delayValue);\n vec4 rgba = mix(rgba1, rgba2, mix(delayValue, threshold, edge));\n rgba *= vec4(vec3(vDark), opacity);\n gl_FragColor = rgba;\n}";